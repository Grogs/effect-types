<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style>
			.reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
				text-transform: none;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown
						 data-separator="^\n\n\n"
						 data-separator-vertical="^\n\n"
						 data-separator-notes="^Note:">
					## Effect Types:
					### What? Why? Which one?

					#### by Greg Dorrell

					Note:
					- Hello everyone. I'm Greg. I used to work for Hotels.com in this office, but I transfered to another one of Expedia's brands, HomeAway, down in Victoria a few months back.
					- I know we're hiring for a number of Scala roles in London across Expedia Group, youif you're curious, you're welcome to grab me later if you want to know about that.
					- Anyway , on with the talk. I'm going to talk about Effect Types...


					## Effect Types
					
					Note:
					- What is an effect type?
					- If you use Slick for working with databases, then you've probably used DBIOAction. That's an effect type, but a bit of a specialist one that you wouldn't use throughout your codebase.
					- We're going to talk about "general effect types", which are types for you to use to encapulate side-effectful code.
					- I'm going advocate that you should use an Effect Type for your side-effectful code.


					## Examples
					- Cats Effect IO
					- Scalaz ZIO
					- Monix Task

					Note:
					- There's a number of effect types that have popped up in Scala in the last couple of years.
					- We're going to focus on these three.
					- We'll take a look at how to use them, and how they compare to each other.


					Not a good effect type:
					## Future

					Note: 
					- But first, we need to talk about Future. I basically want to convince you that Future isn't good for working with side-effectful code.
					- And it's interesting, because I like Futures.
					- They're a great way to work with concurrent and asynchronous code.
					- They compose really nicely (they're monads, so you can use them in for-comprehensions)
					- They're so much better than working with Threads directly and locks.
					- Unfortunately, a lot of us are handling side effects with Future. (E.g. call a database or a webservice)


					## Futures 
					- Good for asynchronous and concurrent code!
					- Bad for working with side effects.

					Note:
					- Future is eager
					- Future is memoized
					- They can be composed nicely (monadically - with for-comprehensions)
					- ...But only if they don't have side effects (or you're careful)!


					> "creating a Future that induces a side-effect is in itself also a side-effect, due to Future's eager nature"

					###### from https://stackoverflow.com/a/44196745

					Note:
					- This is an important point that's easy to gloss over (I know I did!)
					- So, what does this mean?
					- Well. As soon as you create a Future. It's scheduled against an ExecutionContext and runs.
					- If inside the Future, you perform a side-effect, then just creating the Future causes a side effect!
					- Okay... So the question is why should we care? Is this actually important? I don't have any problems with it!
					

					
					## Why are side effects bad?

					Note:
					- Put Future aside for a second, why do we avoid side effects in most of our code?
					- Avoiding side effects make it easier to reason about and compose. 
					- This is the reason for FP and types. It's easier. 
					- When I see a function which returns Unit, I have no idea what it does, and I have to go look. 
					- And importantly, I probably have to be careful to run it at the right time when the system is in the right state.


					*demo*


					### Futures are good  
					
					Side effects are neccessary  

					#### Future  are bad for side effects

					Note:
					- As soon as you do side effects inside a Future, it becomes hard to reason about and compose. 
					- We need side effects, and we want to do them in parallel and asynchronously.
					- It's just that Effect types are better for writing effectful async and concurrent code.					



					## Monix
					Note:
					Let's start with Monix


					A library for asynchronous programming in Scala
					Note:
					- What does that mean? It sounds super general.
					- Well, Monix actually has a few different useful sub-projects
					- monix-execution provides utilities for working with `scala.concurrent`. Such as a scheduler, cancellable futures, other utilies like an AsyncSemaphore which I've found useful.
					- But today we're going to focus on Monix Task


					monix-eval provides Task

					Task is an effect type
					Note:
					- Nothing about Future suggest you should do side effects inside them.
					- You can use them for running CPU-bound referentially transparent code concurrently.
					- But in reality, most of us put effects inside Futures
					- Task is an alternative way to handle effects


					Unlike a Future, a Task is not eager.
					Note: It's lazy


					You have to explicitly run it.


					If you run a Task twice, it will actually run twice.
					Note:
					So it's not memoized


					*demo*
					Note:
					- DEMO
					- Other than being lazy and not memoized, it's pretty similar to Future.
					- It still has a failure case, which is Exception.
					- Timeout-able. Actually cancels. `memoize`, `memoizeOnSuccess`, `onErrorRestart`


					What about parallelism?
					Note: 
					- By being lazy, we've made it more awkward to run Tasks in parallel
					- They're referentially transparent, so "extract variable" in IntelliJ won't work.
					- Instead, you have to be explicit about it.


					*demo*


					What happened to the ExecutionContext? 
					Note:
					- I've glossed over where these Tasks actually run.
					- Like Future we need a threadpool which actually runs these tasks.
					- In Monix, that's called a scheduler.
					

					*demo*

					Note:
					- You only provide it when you run your Task
					- For CPU-bound stuff, use global. For blocking IO, use a separate scheduler. 
					- Monix lets you create a Scheduler from an ExecutionContext. And provides convenience methods for creating them, e.g. for IO.


					Other benefits
					Note:
					- So far I've focusing on them being better to reason about and work with.
					- But there good reasons to use Monix or Cats IO, or ZIO, even without that.


					### Performance

					see https://bit.ly/2DIPiJw
					Note:
					- With Future, every time you `map` or `flatMap`, you schedule a task against an execution context.
					- It goes into a queue and is then picked up.
					- With all these effect types, it's lazy and you specify the threadpool at the end
					- This allows `map` operations, and potentially a subset of `flatMap`s to be chained together and all run immediately after one another on the same thread.
					- This can give significant performance improvements.


					Resource Safety
					Note:
					- All of these effect types implement `cats.effect.Bracket` which provides resource safety
					- Essentially this is equivalent to a finally block of a try-catch.



					## Cats Effect IO
					Note: This is another effect type, under the cats ecosystem


					Similar to Monix
					Note:
					- Which is perhaps not surpising as the largest contributor to Cats Effect is the creator of Monix.
					- But there are some differences. Mostly it's restrictions. 
					- Monix is pragmatic. It's familiar coming from Future. It provides lots of convenience functions through its' API.
					- Cats Effect API makes it harder to run IO's in paralle, for example. 

					
					*demo*



					## Scalaz ZIO's IO


					Once again, similar.
					Note:
					- I've not looked into it too much.
					- But it's lazy and not memoized, so it's referentially transparent and easy to reason about.
					

					Main difference: ZIO's IO is a bifunctor
					Note:
					- Anything you can map over is a Functor.
					- Anything where you have the idea or a left and right value is a bifunctor.
					- In the standard library we have a Bifunctor - Either. You can map over the right hand side or the left hand side.
					- With Future and Cats IO and Monix Task, there's a "left hand side" too. But it's always Throwable.
					- ZIO lets you use any error type you like.
					- This is great for people that are using Future of Either, and probably using monad transformers (EitherT), and probably wondering if they should just make all their errors Throwable (but not doing so because you lose the ability to restrict error type).
					

					You define the error type

					```scala
					IO.point("Hello World") //scalaz.zio.IO[Nothing, String]
					```
					Note:
					- Cats Effect and Monix take the approach that the failure type has to be Throwable
					- Just as Future does
					- ZIO doesn't.


					*demo*
					


					Cats Effect also provides typeclasses for effect types.


					Just as List has Applicative, Monad, and Foldable...


					...an "effect" type can have Bracket, Sync, Async, and Concurrent


					#### from https://twitter.com/impurepics
					![](cats-effect-typeclasses-cheat-sheet.png)


					ZIO, Cats IO, and Monix Task  
					all implement these typeclasses.
					Note:
					- This means there's really good interop between them
					- And libraries coded against cats effect can work with any of the effect types I've shown you
					- E.g. Doobie, fs2, finch and http4s all work with all of these effect types.


					Just as cats NonEmptyList is a more restricted List...
					...cats IO is a more restricted Task.
					Note:
					And ZIO is less restrictive (in that you choose the error type)


					*demo*



					Disadvantages
					- More to learn
					- Less widely supported

					Note:
					- But actually not much more to learn. They compose the same.
					- Adoption is pretty good. doobie, fs2, http4s, finch. 
					- But if you're using Play or Akka Streams, you're going to have to interop.
					- That's okay, just code your services against an effect type, then run to Future in your controller or `mapAsync`.


					### Summary
					- Side effects in Futures is bad.
					- Effect types help with that and offer better performance, cancellation, resource safety
					- Monix is the easiest to move to
					- Cats and ZIO are more principled
					- The fact ZIO is a bifunctor is less useful than expected

					Note:
					- Side-effecting Future are hard to reason about and compose
					- There are a number of good alternatives.
					- But you also get better performance, proper timeouts, resource safety, useful concurrency primitives.
					- I think Monix Task is the easiest to migrate to from Future. It's also the most mature and has really good docs.
					- Cats and ZIO are both more principled. They make it harder to make mistakes, but in return it can be more awkward to find things in the API etc.
					- Cats Effect also gives you the typeclasses, this is great - it massive helps the interop and ibrary support. but it doesn't mean you ahve to use Cats Effect IO.
					- ZIO lets you control the error type. There's more important tax, the docs are still a work in progress
					- Personally, I'm coding against cats effect and using Monix Task in personal projects.
					- At work, we use cats extensively, and I believe it would be a good move to code against cats effect and use Monix.
					- We also use EitherT a lot with Future... I'd like to be able to control the error type... But that doesn't work with Cats Effect (and therefore libraries using it), at least for now.
					- Trade offs:
						- More to learn, but not that much I think.
						- Less widely supported than Future.


					# Questions?

					slides: http://gregd.me/effect-types/  
					code: https://github.com/Grogs/effect-types


					## Resources
					https://typelevel.org/cats-effect/
					https://scalaz.github.io/scalaz-zio/
					https://monix.io/docs/3x/eval/task.html

					Note:

				</section>
			</div>
		</div>

		<!--Future is eager. If your Future is side-effecting, then creating the Future is side-effecting.-->

		<!--No eager evaluation. That gives you equational reasoning. That means the for comprehension with 2 futures exmple is different.-->

		<!--Lower adoption-->
		<!-- - timing out, firstcompleteof-->
		<!-- - resource management-->
		<!--ZIO-->
		<!--https://twitter.com/jdegoes/status/1071757668757528576-->
		<!--Cats Effect-->
		<!--pure/apply/async/error???-->
		<!--cats io - no concurrency? :O-->
		<!--but provides laws/abstractions-->

		<!--
Task & IO Monad.
	- Referential transparency
	- Performance
	- Cancellable?
	- https://monix.io/api/3.0/monix/eval/Task.html
		- A Task, and IO Monad are not eager, and can be run multiple times.
		- Monix Task still interoporates will with Future. You can create a Task from a Future using
		- You still have map and flatMap, so you can use it in for-comprehensions.
		- But you also have loads of other methods. Some of which you might find useful. Here's some I think are cool/useful:

https://stackoverflow.com/questions/44196088/why-future-has-side-effects
https://medium.com/@yuriigorbylov/is-future-a-monad-d7e4e07ddd82
https://medium.com/@sderosiaux/are-scala-futures-the-past-69bd62b9c001
https://www.reddit.com/r/scala/comments/3zofjl/why_is_future_totally_unusable/
http://www.beyondthelines.net/programming/futures-vs-tasks/
https://pierangeloc.github.io/blog/2018/06/01/on-RT-and-FP

		-->
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// Reveal.configure({ slideNumber: 'c/t' });
			// Reveal.configure({ showSlideNumber: 'speaker' });

			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
				controlsTutorial: false,
				showNotes: true,
				slideNumber: 'c/t',
				showSlideNumber: 'speaker',
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
