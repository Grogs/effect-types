<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		<style>
			.reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
				text-transform: none;
			}
		</style>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown
						 data-separator="^\n\n\n"
						 data-separator-vertical="^\n\n"
						 data-separator-notes="^Note:">
					## Effect Types:
					### What? Why? Which one?

					#### by Greg Dorrell

					Note:
					- I'm Greg. I work for HomeAway, which is part of Expedia Group, but we have our own office down in Victoria. 
					- But I also worked for Hotels.com before transferring HomeAway. I know Hotels, HomeAway, and Brand Expedia (also based here) all have Scala teams and are hiring. You're welcome to chat to me about that later if you like.
					- Anyway, on with the talk. I'm going to talk about Effect Types...


					## Effect Types
					
					Note:
					- What is it?
					- A "general effect type" is a type that you use to encapulate side-effecting operations.
					- I'm going advocate that you should use an Effect Type for side-effectful code.


					## Examples
					- Cats Effect IO
					- Scalaz ZIO
					- Monix Task

					Note:
					- A number of effect types have popped up in Scala in the last couple of years.
					- Here's a few of them
					- We'll take a look at these ones, and how they compare.
					- BTW, another example is Slick's DBIO Action. We're going to talk about "general effect types", but it's interesting to note that Slick introduced its own effect type. That at least suggests effect types aren't just for "strong FP" codebases.


					Not a good effect type:
					## Future

					Note: 
					- We need to talk about Future.
					- I like Futures. They really impressed me when I moved from Java to Scala.
					- Working with them is so much better than working with Threads and locks.
					- Unfortunately, a lot of us are handling side effects with Future.


					## Futures 
					- Good for asynchronous and concurrent code!
					- Bad for working with side effects.

					Note:
					- Futures are placeholders for objects which may or may not exist yet.
					- Future is eager
					- Future is memoized
					- They can be composed nicely (monadically - with for-comprehensions)
					- ...But only if they don't have side effects (or you're careful)!


					> "creating a Future that induces a side-effect is in itself also a side-effect, due to Future's eager nature"

					###### from https://stackoverflow.com/a/44196745

					Note:
					- This is an important point that's easy to gloss over (I know I did!)
					- So, what does this mean?
					- Well. As soon as you create a Future. It's scheduled against an ExecutionContext and runs.
					- If inside the Future, you perform a side-effect, then just creating the Future causes a side effect!
					- Okay... So the question is why should we care? Is this actually important? I don't have any problems with it!
					

					
					## Why are side effects bad?

					Note:
					- Put Future aside for a second, why do we avoid side effects in most of our code?
					- Avoiding side effects make it easier to reason about and compose. 
					- This is the reason for FP and types. It's easier. 
					- When I see a function which returns Unit, I have no idea what it does, and I have to go look. 
					- And importantly, I probably have to be careful to run it at the right time when the system is in the right state.


                    *demo*


                    ### Futures are good  
                    
                    Side effects are neccessary  

                    #### Future  are bad for side effects

					Note:
					- As soon as you do side effects inside a Future, it becomes hard to reason about and compose. 


					What should you use instead?

					Note:
					- We need side effects, and we want to do them in parallel and asynchronously.
					- I'm saying we shouldn't use Future, so we need something else.


					ZIO / Cats Effect IO / Monix
					



					Monix


					A library for asynchronous programming in Scala
					Note:
					- What does that mean? It sounds super general.
					- Well, Monix actually has a few different useful sub-projects
                    - monix-execution provides utilities for working with `scala.concurrent`. Such as a scheduler, cancellable futures, other utilies like an AsyncSemaphore which I've found useful.
                    - But today we're going to focus on Monix Task


                    monix-eval provides Task

					Task is an effect type
					Note:
					- Nothing about Future suggest you should do side effects inside them.
					- You can use them for running CPU-bound referentially transparent code concurrently.
					- But in reality, most of us put effects inside Futures
					- Task is an alternative way to handle effects


                    Unlike a Future, a Task is not eager.
					Note: It's lazy


					You have to explicitly run it.


                    If you run a Task twice, it will actually run twice.


					*demo*
					Note:
                    - DEMO
                    - Other than being lazy and not memoized, it's pretty similar to Future.
                    - It still has a failure case, which is Exception.
                    - Timeout-able. Actually cancels. `memoize`, `memoizeOnSuccess`, `onErrorRestart`


                    What if I want parallelism?
					Note: 
                    - By being lazy, we've made it more awkward to run Tasks in parallel


                    *demo*


                    What happened to the ExecutionContext? 
					Note:
					- I've glossed over where these Tasks actually run.
					- Like Future we need a threadpool which actually runs these tasks.
					- In Monix, that's called a scheduler.
					

					*demo*

					Note:
					- You only provide it when you run your Task
					- For CPU-bound stuff, use global. For blocking IO, use a separate scheduler. 
					- Monix lets you create a Scheduler from an ExecutionContext. And provides convenience methods for creating them, e.g. for IO.



                    ## Cats Effect IO
					Note: This is another effect type, under the cats ecosystem


                    Similar to Monix
					Note:
                    - Which is perhaps not surpising as the largest contributor to Cats Effect is the creator of Monix.
					- But there are some differences. Mostly it's restrictions. 
					- Monix is pragmatic. It's familiar coming from Future. It provides lots of convenience functions through its' API.
					- Cats Effect API makes it harder to run IO's in paralle, for example. 

					
					*demo*



					## Scalaz ZIO's IO


					Once again, similar.
					Note:
					- I've not looked into it too much.
					- But it's lazy and not memoized, so it's referentially transparent and easy to reason about.
					

					Main difference: ZIO's IO is a bifunctor
					Note:
					- Anything you can map over is a Functor.
					- Anything where you have the idea or a left and right value is a bifunctor.
					- In the standard library we have a Bifunctor - Either. You can map over the right hand side or the left hand side.
					- With Future and Cats IO and Monix Task, there's a "left hand side" too. But it's always Throwable.
					- ZIO lets you use any error type you like.
					- This is great for people that are using Future of Either, and probably using monad transformers (EitherT), and probably wondering if they should just make all their errors Throwable (but not doing so because you lose the ability to restrict error type).
					

					You define the error type

					```scala
					IO.point("Hello World") //scalaz.zio.IO[Nothing, String]
					```
					Note:
					- Cats Effect and Monix take the approach that the failure type has to be Throwable
					- Just as Future does
					- ZIO doesn't.


					*demo*
					


					Cats Effect also provides typeclasses for effect types.


					Just as List has Applicative, Monad, and Foldable...


					...an "effect" type can have Bracket, Sync, Async, and Concurrent


					ZIO, Cats IO, and Monix Task  
					all implement these typeclasses.


					Just as cats NonEmptyList is a more restricted List...
					...cats IO is a more restricted Task.
					Note:
					And ZIO is less restrictive (in that you choose the error type)


					*demo*



					Other benefits
					Note:
					- I've focused on the reasoning/composition argument.
					- But there's a bunch of other good reasons.


					Performance

					see https://bit.ly/2DIPiJw
					Note:
					- With Future, every time you `map` or `flatMap`, you schedule a task against an execution context.
					- It goes into a queue and is then picked up.
					- With all these effect types, it's lazy and you specify the threadpool at the end
					- This allows `map` operations, and potentially a subset of `flatMap`s to be chained together and all run immediately after one another on the same thread.
					- This can give significant performance improvements.


					Resource Safety
					Note:
					- All of these effect types implement `cats.effect.Bracket` which provides resource safety
					- Essentially this is equivalent to a finally block of a try-catch.



					### Summary / My thoughts
					- Side-effecting Future are hard to reason about and compose
					- There are a number of good alternatives.
					- But you also get better performance, proper timeouts, resource safety, useful concurrency primitives.
					- Task is the easiest to migrate to from Future.
					- ZIO lets you control the error type. 

					Note:
					- Monix is the most mature. The docs are great!
					- scalaz ZIO is very principled, which prevents you from making mistakes, but can be awkward. The docs not very mature.
					- Personally, I'm coding against cats effect and using Monix Task in personal projects.
					- At work, we use cats extensively, and I believe it would be a good move to code against cats effect and use Monix.
					- We also use EitherT a lot with Future... I'd like to be able to control the error type... But that doesn't work with Cats Effect, at least for now.


					# Questions?

					slides:

					http://gregd.me/effect-types/


					## Resources
					https://typelevel.org/cats-effect/
					https://scalaz.github.io/scalaz-zio/
					https://monix.io/docs/3x/eval/task.html

					Note:

				</section>
			</div>
		</div>

		<!--Future is eager. If your Future is side-effecting, then creating the Future is side-effecting.-->

		<!--No eager evaluation. That gives you equational reasoning. That means the for comprehension with 2 futures exmple is different.-->

		<!--Lower adoption-->
		<!-- - timing out, firstcompleteof-->
		<!-- - resource management-->
		<!--ZIO-->
		<!--https://twitter.com/jdegoes/status/1071757668757528576-->
		<!--Cats Effect-->
		<!--pure/apply/async/error???-->
		<!--cats io - no concurrency? :O-->
		<!--but provides laws/abstractions-->

		<!--
Task & IO Monad.
	- Referential transparency
	- Performance
	- Cancellable?
	- https://monix.io/api/3.0/monix/eval/Task.html
		- A Task, and IO Monad are not eager, and can be run multiple times.
		- Monix Task still interoporates will with Future. You can create a Task from a Future using
		- You still have map and flatMap, so you can use it in for-comprehensions.
		- But you also have loads of other methods. Some of which you might find useful. Here's some I think are cool/useful:

https://stackoverflow.com/questions/44196088/why-future-has-side-effects
https://medium.com/@yuriigorbylov/is-future-a-monad-d7e4e07ddd82
https://medium.com/@sderosiaux/are-scala-futures-the-past-69bd62b9c001
https://www.reddit.com/r/scala/comments/3zofjl/why_is_future_totally_unusable/
http://www.beyondthelines.net/programming/futures-vs-tasks/
https://pierangeloc.github.io/blog/2018/06/01/on-RT-and-FP

		-->
		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
            // Reveal.configure({ slideNumber: 'c/t' });
            // Reveal.configure({ showSlideNumber: 'speaker' });

            // More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				history: true,
                controlsTutorial: false,
				showNotes: true,
                slideNumber: 'c/t',
                showSlideNumber: 'speaker',
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
